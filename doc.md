# 报表简要使用说明 #


## 1.基本概念 ##

### 1.报表计算模型 ###

> 在设计器中单元格之间存在依赖关系，对于任意一个单元格都可以设置它的左父格与上父格。单元格父格是可选的，默认情况下，单元格的左父格就是其最近左边与其位于同一行的单元格；上父格则是其最近上方与其位于同一列的的单元格。如果一个单元格位于第一行，那默认它就没有上父格，同样，如果位于第一列，默认它就没有左父格。打开报表设计器，选中任意单元格，都可以在其属性面板看到它的默认上父格或左父格，如下图所示

![](http://i.imgur.com/8GN2Sod.jpg)

### 2.行类型 ###

> 在报表设计器中，选择任意一行或单元格，点击右键，就可以在弹出菜单中看类类型的定义，如下图所示：

![](http://i.imgur.com/h1wT9mu.jpg)

> 从右键菜单中可以看到，设计器支持将特定行定义成四种特殊类型，分别是：标题行、重复表头行、重复表尾行以及总结行，这些行类型主要是在分页时起作用。

#### 1.标题行 ####

> 所谓标题行，就是在报表计算后分页时只会出现在第一页第一行的行，如果定义了多个行为标题行类型，那么这些行将在报表运行后分页输出时第一页最前面插入标题行。需要注意的是，我们在报表中可以将位于任意位置的行定义成标题行，但报表计算分页输出时，总会将这些定义为标题行的行放在报表的第一页最前端显示。

#### 2.重复表头行 ####

> 与标题行不同的是，定义为重复表头行的行，在报表计算分页输出时会将定义成重复表头行的行放在每一页的前端进行显示。如果当前报表中定义的有标题行，那么对于第一页，标题前将位于最上面，其下才是重复表头行定义的行

#### 3.重复表尾行 ####

> 与重复表头行类型，它也会在报表计算分页输出时放在每一页中显示，只是它会在每一页的最下端显示。

#### 4.总结行 ####

> 与标题行对应，总结行会出现在报表计算后分页输出时最后一页的最下端显示。如果当前报表中定义了重复表尾行，那么在报表计算后分页输出的最后一页中总结后将位于重复表尾行下方显示。

## 2.表达式 ##

> 在报表使用过程当中，不可避免的要使用函数及表达式实现一些数据的计算，在我们的报表当中，很多地方都支持编写表达式，比如最典型的我们可以将单元格类型改为“**表达式**”，这样就可以在下面的表达式编辑器里输入相应的表达式与函数，除此之外，我们的报表还允许我们在条件、图片来源、二维码数据来源等地方使用表达式，所以学习并掌握UReport2中提供的表达式，是制作复杂报表的前提。

### 1.基本语法 ###

#### 1.基本数据类型 ####

| 类型   | 描述               | 示例                                       |
| :--- | :--------------- | :--------------------------------------- |
| 数字   | 可以是一个整数，也可以是一个小数 | 1、123、0.121331，这些都是合法的数字                 |
| 字符串  | 字符串需要用单引号或双引号包裹  | 'ureport2'、"UReport2"、‘UReport2教程’，这些都是合法的字符串 |
| 布尔值  | 布尔值表示是或否         | 布尔就两个：true和false                         |

#### 2.操作符 ####

| 操作符  | 描述              | 示例                                       |
| :--: | :-------------- | :--------------------------------------- |
|  +   | 求两个数的和，或者是连接两个值 | 21+31，这就表示求这两个数的和，结果就是52，“值：”+331则表示连接两个值，其结果就是“值：331” |
|  -   | 求两个数差           | 21 - 31，这就表示求这两个数的差，结果就是-10              |
|  \*  | 求两个数的乘积         | 3\*6，结果就是18                              |
|  /   | 求两个数除的结果        | 6/3，结果就是2，如果除不尽，则会保留8位小数                 |
|  %   | 求两个数除的余值        | 5%3，结果是2；6%2结果是0                         |


### 2.三元表达式 ###

| 三元表达式示例                                  | 描述                                       |
| :--------------------------------------- | :--------------------------------------- |
| A1\>1000 ? "正常值" : "低值"                  | 表达式计算时，先取到A1单元格的值，判断值是否大于1000，如果是返回“正常值”字符串，否则返回“低值”字符串 |
| A1\>1000 and A1<20000 ? "正常值" : "修正值："+(A1+100) | 条件部分，判断A1值是否大于1000且小于20000，如果是返回"正常值"，否则返回字符串”修正值“与A1值加100后结果连接的值，如果A1是2000，那么就返回”修正值：2100“ |

### 3.if判断 ###

| if判断示例                                   | 描述                                       |
| :--------------------------------------- | :--------------------------------------- |
| if(A1\>1000){return "正常值"}               | 判断A1单元格的值是不是大于1000，如果是返回”正常值“字符串，否则什么都不做 |
| f(A1\>1000){"正常值"}else{"低值"}             | 判断A1单元格的值是不是大于1000，如果是返回”正常值“字符串，否则返回”低值“字符串。 |
| if(A1\>1000 and A1\<20000){"正常值:"+A1}else if(A\>20000 and A1\<40000){"超高值"}else{"低值"} | 在这个例子当中，条件部分添加了多个组合条件，同时elseif多重判断       |

### 4.单元格引用 ###

> 在报表当中，大多数的计算都是针对单元格或与单元格有关，因为报表中单元格多数都与数据绑定，而数据往往又是多条，所以计算后的报表一个单元格会产生多个，这样对于单元格的引用就变的比较复杂。在报表设计器中，引用的目标单元格是相对当前单元格来进行计算的，引用方法就是直接在表达式里书写单元格名称，比如引用A1单元格，就直接写A1即可，如下面的例子：

![](http://i.imgur.com/Luoorwu.png)

> 在上图当中，我们在D1单元格中输入表达式A1，这就表示，在D1单元格里填入相对当前D1单元格的A1单元格的值，运行后的效果如下：

![](http://i.imgur.com/ItiHpNt.png)

> 可以看到，因为D1是A1的子格，A1单元格绑定的数据就是分组结构，根据当前D1单元格的位置，就产生的上图所示的结果。如果在D1单元格中输入B1，那么运行后的效果又是下图的样子：

![](http://i.imgur.com/BRj7s7Q.png)

> 通过上面的例子我们可以看到，某个单元格的表达式引用目标单元格，首先判断的是目标单元格与其所在单元格是否位于同一行或行，如果是则直接取对应行或列上目标单元格的值。如果当前单元格与目标单元格不在同一行或列，那情况又不一样了，我们来看下一个例子。

![](http://i.imgur.com/qV6lw5s.png)

> 在上面的例子中，我们在C2单元格的表达式中输入B1，表示取B1单元格的值，但B1单元格又和C2不在同一行或列上，同时B1单元格展开后会有多个值，但B1单元格和C2单元格都拥有一个共同的父格或间接父格A1（C2单元格的左父格是B2，而B2单元格的左父格又是A1，所以A1是C2单元格的间接左父格），所以它会取他们共同父格A1下所有B1的值，运行结果如下图所示：

![](http://i.imgur.com/Uayghmy.png)

> 针对上面的例子，如果我们在上面的单元格中输入C1，那结果又不一样；因为C1是C2的上父格，所以将直接取与其位于同一列的上父格单元格的值，运行效果如下图所示：

![](http://i.imgur.com/1fiM9LY.png)

> 再看下面的报表示例：

![](http://i.imgur.com/DB2g3nr.png)

> 在上面的例子中，B2单元格表达里输入C1，因为B2和C2既不在同一行或列，也没有共同的父格，所以B2中将取到所有的C1单元格的值，如下图所示：

![](http://i.imgur.com/9vzZPPX.png)

### 5.单元格坐标 ###

> 为了实现更为复杂的单元格引用，设计器引用了单元格坐标的概念。单元格坐标，也是相对于当前单元格来进行计算的，同样遵循上面的介绍的优先取同行、同列或共同父格的原则，一个标准的单元格坐标格式如下：
> > 单元格坐标格式:单元格名称[Li:li,Li-1:li-1,…;Ti:ti,Ti-1:ti-1…]{条件...}

> L表示左父格，l表示左父格展示后的序号，序号为负值，表示向上位移；T表示上父格，t表示上父格展开后的序号，序号为负值，表示相对于当前单元格向上位移，正值则表示向下位移，如果只有左父格，那么直接写L部分即可；如果只是上父格，那么前面需要加上“;”号，然后写T部分，后面的大括号中是条件部分，多个条件之间用and/or连接，表示对通过坐标取到的单元格进行条件过滤（如果取到多个单元格的话），条件部分是可选的，相关示例如下：

| 单元格坐标示例                               | 描述                                       |
| :------------------------------------ | :--------------------------------------- |
| C1[A1:2,B1:1]                         | 在找C1时先找单元格A1展开后的第2格；再找第二个A1下的B1单元格展开后的第一个单元格，然后再找这个B1单元格对应的C1单元格 |
| C2[A1:2,B1:2;C1:3]                    | 在找C2时，先找A1单元格展开后的第二格，再找第二个A1单元格下B2单元格展开后的第二格，再根据第二个展开的B2单元格找其下名为C2单元格的左子格；然后再找到C1单元格展开后的第三格，再看其下的C2单元格，取C2单元格的交集 |
| C2[A1:2,B2:2]{C2\>1000}               | 表示取A2单元格展开后的第二格，再取其下B2单元格展开后第二格，再取B2下所有的C2单元格，最后再对取到的C2单元格进行条件过滤，只取出C2单元格值大于1000的所有C2单元格。 |
| C2[A1:2,B2:2]{C2\>1000 and C2\<10000} | 表示取A2单元格展开后的第二格，再取其下B2单元格展开后第二格，再取B2下所有的C2单元格，最后再对取到的C2单元格进行条件过滤，只取出C2单元格值大于1000且小于10000的所有C2单元格的值。 |

> 我们来看一个具体的示例，报表模版如下：

![](http://i.imgur.com/ZjsItt1.png)

> 在上面的报表模版中，在B2单元格表达式里，我们输入了C1[A1:2,B1:1]，这就表示取A1单元格展开后第二格下B1单元格展开后第一格下对应的C1单元格的值，所以运行后我们可以看到如下图所示效果：

![](http://i.imgur.com/ewOXVHN.png)


## 3.函数 ##

### 1.常用函数 ###

#### 1.count函数(统计数量) ####

> count函数是对给定的表达式在计算后对象数量进行统计。

| 示例                                       | 说明                                       |
| :--------------------------------------- | :--------------------------------------- |
| count(C1)                                | 统计相对当前所在单元格，目标C1单元格数量                    |
| count(C1{age\>20})                       | 统计相对当前所在单元格，目标C1单元格绑定对象的age属性大于20的C1单元格数量 |
| count(C1,C2)                             | 统计相对当前所在单元格，目标C1单元格以及C2单元格加在一起的数量        |
| count(C1{age\>20},C2{salary\>2000 and degree=='本科'}) | 统计相对当前所在单元格，目标C1单元格绑定对象的age属性大于20的C1单元格以及C2单元格绑定对象的salary属性大于2000同时degree属性等于本科的单元格数量 |

#### 2.sum函数(累加) ####

> sum函数是对给定的表达式在计算后值进行累加，sum函数要求各个表达式计算后的值必须是数字，否则将产生错误。

| 示例                                       | 说明                                       |
| :--------------------------------------- | :--------------------------------------- |
| sum(C1)                                  | 相对当前单元格，取到所有C1单元格值进行累加                   |
| sum(C1,C2)                               | 相对当前单元格，取到所有C1和C2单元格的值进行累加               |
| sum(C1{age\>20})                         | 相对当前单元格，取到所有绑定对象属性age大于20的C1单元格值进行累加     |
| sum(C1{age\>20},C2{salary\>2000 and degree=='本科'}) | 相对当前单元格，取到所有绑定对象属性age大于20的C1单元格值以及绑定对象属性salary大于2000且degree属性等于本科的C2单元格的值进行累加 |

#### 3.avg函数(求平均值) ####

> avg函数是对给定的表达式在计算后值求平均值，avg函数要求各个表达式计算后的值必须是数字，否则将产生错误。

| 示例                                       | 说明                                       |
| :--------------------------------------- | :--------------------------------------- |
| avg(C1)                                  | 相对当前单元格，求C1单元格的平均值                       |
| avg(C1{age\>20})                         | 相对当前单元格，取到绑定对象属性age大于20的C1单元格值的平均值       |
| avg(C1,C2)                               | 相对当前单元格，求C1和C2单元格的平均值                    |
| avg(C1{age\>20},C2{salary\>2000 and degree=='本科'}) | 相对当前单元格，取到所有绑定对象属性age大于20的C1单元格值以及绑定对象属性salary大于2000且degree属性等于本科的C2单元格的值进行求平均值 |

#### 4.max函数(求最大值) ####

> max函数是对给定的表达式在计算后值求其中的最大值，max函数要求各个表达式计算后的值必须是数字，否则将产生错误。

| 示例                                       | 说明                                       |
| :--------------------------------------- | :--------------------------------------- |
| max(C1)                                  | 相对当前单元格，求C1单元格的最大值                       |
| max(C1{age\>20})                         | 相对当前单元格，取到绑定对象属性age大于20的C1单元格值的最大值       |
| max(C1,C2)                               | 相对当前单元格，求C1和C2单元格的最大值                    |
| max(C1{age\>20},C2{salary\>2000 and degree=='本科'}) | 相对当前单元格，取到所有绑定对象属性age大于20的C1单元格值以及绑定对象属性salary大于2000且degree属性等于本科的C2单元格的值进行求最大值 |

#### 5.min函数(求最小值) ####

> min函数是对给定的表达式在计算后值求其中的最小值，min函数要求各个表达式计算后的值必须是数字，否则将产生错误。

| 示例                                       | 说明                                       |
| :--------------------------------------- | :--------------------------------------- |
| min(C1)                                  | 相对当前单元格，求C1单元格的最小值                       |
| min(C1{age\>20})                         | 相对当前单元格，取到绑定对象属性age大于20的C1单元格值的最小值       |
| min(C1,C2)                               | 相对当前单元格，求C1和C2单元格的最小值                    |
| min(C1{age\>20},C2{salary\>2000 and degree=='本科'}) | 相对当前单元格，取到所有绑定对象属性age大于20的C1单元格值以及绑定对象属性salary大于2000且degree属性等于本科的C2单元格的值进行求最小值 |

#### 6.row函数（取行号）####

> 取当前单元格所在行的行号，这个函数比较简单，它没有参数。

| 示例    | 说明           |
| :---- | :----------- |
| row() | 取当前单元格所在行的行号 |

#### 7.column函数（取列号）####

> 取当前单元格所在列的列号，这个函数比较简单，它没有参数。

| 示例       | 说明           |
| :------- | :----------- |
| column() | 取当前单元格所在列的列号 |

### 2.分页相关函数 ###

> 所谓分页相关函数，是指这些函数是在分页的时候进行计算，比如计算当前页有多少条记录、当前页某个单元格值累加后是多少、平均值是多少、最大值是多少等等。

#### 1.pcount函数 ####

> 统计当前页下表达对应值的数目，与count函数的使用方法基本一致，不同之处在于pcount只会统计当前页中对应的表达式内容的数目。

| 示例                       | 说明                                       |
| :----------------------- | :--------------------------------------- |
| pcount(C1)               | 统计当前页中，C1单元格数目                           |
| pcount(C1,D2{D2\>10000}) | 统计当前页中，C1单元格和当前页中所有D2单元格值大于10000的D2单元格数目 |

#### 2.psum函数 ####

> 将当前页下表达式对应的所有值进行累加，与sum函数对应，不同的是psum只针对当前页。

| 示例                     | 说明                                  |
| :--------------------- | :---------------------------------- |
| psum(C1)               | 将当前页中，所有C1单元格值进行累加                  |
| psum(C1,D2{D2\>10000}) | 将当前页中，所有C1单元格值以及值小于10000的D2单元格值累加起来 |

#### 3.pmax函数 ####

> 比较当前页中，表达式对应的值，找出其中最大的那个值，与max函数对应，只是pmax只针对当前页。

| 示例                     | 说明                                      |
| :--------------------- | :-------------------------------------- |
| pmax(C1)               | 比较当前页中所有C1单元格值，找出最大值。                   |
| pmax(C1,D2{D2\>10000}) | 比较当前页中，所有C1、D2以及值大于1000的E2单元格值，找出其中最大的。 |

#### 4.pmin函数 ####

> 比较当前页中，表达式对应的值，找出其中最小的那个值，与min函数对应，只是pmin只针对当前页。

| 示例                      | 说明                                      |
| :---------------------- | :-------------------------------------- |
| pmin(C1)                | 比较当前页中所有C1单元格值，找出最小值。                   |
| pmin(C1,D2,E2{E2\>1000}) | 比较当前页中，所有C1、D2以及值大于1000的E2单元格值，找出其中最小的。 |

#### 5.page函数 ####

> 输出当前所在页的页码，该函数没有参数。

| 示例     | 说明          |
| :----- | :---------- |
| page() | 输出当前所在页的页码。 |

#### 6.pages函数 ####

> 输出当前报表一共有多少页，该函数没有参数。（pages函数目前仅能在页眉页脚中使用）

| 示例      | 说明            |
| :------ | :------------ |
| pages() | 输出当前报表一共有多少页。 |

### 3.数学函数 ###

#### 1.abs函数（绝对值） ####

> 求参数的绝对值，参数值计算后数据类型必须是数字，否则会报错。

| 示例      | 说明            |
| :------ | :------------ |
| abs(-233) | 求-233绝对值，计算后的值是233 |
| abs(C1) | 相对当前单元格，取到C1单元格的值，如果有多个则取第一个值返回其绝对值 |

#### 2.ceil函数（最小值） ####

> 对参数值取最小值，如果参数值为小数将舍弃小数点后面的小数部分，参数值计算后数据类型必须是数字，否则会报错。

| 示例      | 说明            |
| :------ | :------------ |
| ceil(32.32) | 计算后值为32 |
| ceil(C1) | 相对当前单元格，取到C1单元格的值，如果有多个则取第一个值返回其最小值 |

#### 3.floor函数（最大值） ####

> 对参数值取最大值，如果参数值为小数将四舍五入小数点后面的小数部分，参数值计算后数据类型必须是数字，否则会报错。

| 示例      | 说明            |
| :------ | :------------ |
| floor(32.52) | 计算后值为33 |
| floor(C1) | 相对当前单元格，取到C1单元格的值，如果有多个则取第一个值返回其最大值 |

#### 4.chn函数（数字转中文） ####

> 将一个数字转化成中文，参数值计算后数据类型必须是数字，否则会报错。

| 示例      | 说明            |
| :------ | :------------ |
| chn(213) | 计算后的值为：贰佰壹拾叁 |
| chn(C1) | 相对当前单元格，取到C1单元格的值，如果有多个则取第一个值，再转化成中文 |

#### 5.cos函数（求余弦） ####

> 求参数的余弦值，参数值计算后数据类型必须是数字，否则会报错。

| 示例      | 说明            |
| :------ | :------------ |
| cos(213) | 计算后的值为：0.8090276252864301 |
| cos(C1) | 相对当前单元格，取到C1单元格的值，如果有多个则取第一个值，再求其余弦值 |

#### 6.sin函数（正弦） ####

> 求参数的正弦值，参数值计算后数据类型必须是数字，否则会报错。使用方法同cos()

#### 7.tan函数（正切） ####

> 求参数的正切值，参数值计算后数据类型必须是数字，否则会报错。使用方法同cos()

#### 8.exp函数（方法用于返回自然数底数e的参数次方） ####

> 求参数的自然数底数e的参数次方，参数值计算后数据类型必须是数字，否则会报错。使用方法同cos()

#### 9.log10函数（返回以10为底的对数值） ####

> 求参数以10为底的对数值，参数值计算后数据类型必须是数字，否则会报错。使用方法同cos()

#### 10.log函数（自然对数） ####

> 求参数自然对数值，参数值计算后数据类型必须是数字，否则会报错。使用方法同cos()

#### 11.median函数（中位数） ####

> 求一组数据的中位数，参数值计算后数据类型必须是数字，否则会报错。

| 示例      | 说明            |
| :------ | :------------ |
| median(12,42,31) | 运行结果为31 |
| median(C1) | 相对当前单元格，取到C1单元格的所有值，再取这些值中位数 |
| median(C1,C2) | 相对当前单元格，取到C1单元格和C2单元格的所有值，再取这些值中位数 |

#### 12.mode函数（众数） ####

> 求一组数据的众数，参数值计算后数据类型必须是数字，否则会报错。

| 示例      | 说明            |
| :------ | :------------ |
| mode(12,42,3,12) | 运行结果为12 |
| mode(C1) | 相对当前单元格，取到C1单元格的所有值，再取这些值众数 |
| mode(C1,C2) | 相对当前单元格，取到C1单元格和C2单元格的所有值，再取这些值众数 |

#### 13.vara函数（方差） ####

> 求一组数据的方差，参数值计算后数据类型必须是数字，否则会报错。使用方法同median()

#### 14.stdevp函数（标准差） ####

> 求一组数据的标准差，参数值计算后数据类型必须是数字，否则会报错。使用方法同median()

#### 15.pow函数（返回第一个参数的第二个参数次方） ####

> pow函数需要两个参数，第一个为需要计算的数字或表达式，第二个为具体的次方。

| 示例      | 说明            |
| :------ | :------------ |
| pow(3,2) | 表示计算3的2次方值，运算后的结果为9 |
| pow(C1,3) | 相对当前单元格，取到C1单元格的值，如果取到的C1单元格有多个，则取第一个，再对其值求3次方 |

#### 16.random函数（随机数） ####

> 生成一个随机数，可以有一个数字类型的参数或表达式，如果有参数，那么以这个参数作为生成随机数字的种子，如果没有则生成一个0~1之间的随机数。

| 示例      | 说明            |
| :------ | :------------ |
| random() | 生成一个0~1之间的随机数 |
| random(10) | 生成一个1~10之间的随机数 |
| random(C1) | 相对当前单元格，取到C1单元格的值，如果取到的C1单元格有多个，则取第一个，再将这个值作为种子生成一个随机数 |

#### 17.round函数（四舍五入） ####

> 对一个小数进行四舍五入，它需要两个参数，第一个参数要进行四舍五入的小数或表达式，第二个为一个可选的要保留的小数位数，如果没有，则不保留小数。

| 示例      | 说明            |
| :------ | :------------ |
| round(32.12) | 计算后的值为32 |
| round(32.123,2) | 计算后的值为32.12 |
| round(C1,2) | 相对当前单元格，取到C1单元格的值，如果取到的C1单元格有多个，则取第一个，然后对这个值做保留两位小数的四舍五入操作 |

#### 18.sqrt函数（平方根） ####

> 求一个数字或表达式计算后值的平方根，参数值计算后数据类型必须是数字，否则会报错。

| 示例      | 说明            |
| :------ | :------------ |
| sqrt(2) | 计算后的值为：1.414214 |
| sqrt(C1) | 相对当前单元格，取到C1单元格的值，如果取到的C1单元格有多个，则取第一个，然后对这个值进行取平方根计算 |

### 4.日期函数 ###

#### 1.date函数（日期） ####

> 输出日期，date函数可以有一个参数，就是日期格式，如果没有则采用yyyy-MM-dd HH:mm:ss格式输出日期。

| 示例      | 说明            |
| :------ | :------------ |
| date() | 以yyyy-MM-dd HH:mm:ss格式输出当前日期，如：2010-08-15 08:45:10 |
| date('yyyy年MM月dd日') | 以yyyy年MM月dd日格式输出当前日期，如：2010年08月15日 |

#### 2.day函数（天） ####

> 输出当前在月份中的天，该函数没有参数。

| 示例      | 说明            |
| :------ | :------------ |
| day() | 可能输出15，表示当前为15日 |

#### 3.month函数（月） ####

> 输出当前月份，该函数没有参数。用法同day()

#### 4.year函数（年） ####

> 输出当前年份，该函数没有参数。用法同day()

#### 5.week函数（星期） ####

> 输出当前是星期几，该函数没有参数。

| 示例      | 说明            |
| :------ | :------------ |
| week() | 输出值可能是“星期三”，表示当前为星期三 |

### 5.字符串函数 ###

#### 1.indexOf函数(位置) ####

> 用于返回一个字符串，在目标字符串中的位置，该函数至少需要两个参数，第一个为目标字符串，第二个为要查找的字符串，如果有三个参数，那么第三个就是开始查找的位置信息，第三个参数必须是一定大于等于0的数字。

| 示例      | 说明            |
| :------ | :------------ |
| indexof('中华人民共和国','共和') | 表示要从"中华人民共和国"这个字符串中找到“共和”字符串的位置 |
| indexof('中华人民共和国','共和',2) | 表示要从"中华人民共和国"这个字符串中第二个字符开始始，找到“共和”字符串的位置 |
| indexof(C1,"人民",2) | 相对于当前单元格，找到C1单元格，如果C1单元格有多个，则取第一个单元格值，再从这个值中第2个位置开始找到“人民”字符串的位置 |

#### 2.length函数（长度） ####

> 求目标字符串长度，该函数必须要有一个参数。

| 示例      | 说明            |
| :------ | :------------ |
| length("中华人民共和国") | 7 |
| length(C1) | 相对于当前单元格，找到C1单元格，如果C1单元格有多个，则取第一个单元格值，然后计算这个值长度 |

#### 3.lower函数（转小写） ####

> 将参数中英文全部转为小写，该函数必须要有一个参数。

| 示例      | 说明            |
| :------ | :------------ |
| lower("Super Man") | 计算后的结果为：super man |
| lower(C1) | 相对于当前单元格，找到C1单元格，如果C1单元格有多个，则取第一个单元格值，然后将这个值中所有英文转换成小写 |

#### 4.upper函数（转大写） ####

> 将参数中英文全部转为大写，该函数必须要有一个参数。用法同lower()

#### 5.replace函数（替换字符串） ####

> 这个函数需要有三个参数，第一个是目标字符串，第二个是要被替换的字符串，第三个是要替换的字符串。

| 示例      | 说明            |
| :------ | :------------ |
| replace("他是一个好人","他","她") | 计算结果为：她是一个好人 |
| replace(C1,"他","她") | 相对于当前单元格，找到C1单元格，如果C1单元格有多个，则取第一个单元格值，然后再将这个值中所有“他”换成“她” |

#### 6.substring函数（子字符串） ####

> 该函数允许有三个参数，第一个是原字符串，第二个为开始截取的位置，第三个为截取结束的位置，第三个缺省即为字符串尾部。

| 示例      | 说明            |
| :------ | :------------ |
| substring("他是一个好人",2) | 运行结果为：一个好人 |
| substring("他是一个好人",2,4) | 运行结果为：一个 |
| substring(C1,2,10) | 相对于当前单元格，找到C1单元格，如果C1单元格有多个，则取第一个单元格值，然后再取这个值中第2到第10个字符之间内容 |

#### 7.trim函数（去空格） ####

> 去除目标字符串两边空格，该函数要求必须要有一个参数。

| 示例      | 说明            |
| :------ | :------------ |
| trim(" 一个好人 ") | 运行结果为：一个好人 |
| trim(C1) | 相对于当前单元格，找到C1单元格，如果C1单元格有多个，则取第一个单元格值，然后再将这个值两边可能存在的空格全部去除 |

## 3.数据引用 ##

### 1.配置数据源 ###

> 新建数据源

![](http://i.imgur.com/262QTp9.png)

> 填写数据源信息，数据源名称自己定义，Bean ID填写配好的Bean。

![](http://i.imgur.com/uVVadTr.png)

> 填写数据集信息，数据集名称自己定义，方法名选择及返回对象对应填写。

![](http://i.imgur.com/3LHTcKw.png)

> 刷新字段

![](http://i.imgur.com/AY7xTxm.png)

### 2.设置数据集单元格 ###

> 选中单元格，单元格属性设置中类型为“数据集”，选择对应的数据源及属性

![](http://i.imgur.com/euBKrdt.png)

### 3.表达式引用单元格 ###

> 选中单元格，单元格属性设置中类型为表达式，表达式一栏填写表达式

![](http://i.imgur.com/ENaWqlP.png)

> 语法规则如下：数据集名称.聚合方式(字段名[,条件,排序方式])，具体聚合类型有以下几种：

#### 1.select(罗列数据) ####

| 示例      | 说明            |
| :------ | :------------ |
| ds1.select(username) | 取数据集ds1中所有的username字段信息 |
| ds1.select(username,age>18) | 取数据集ds1中所有的age属性大于18的username字段信息 |
| ds1.select(username,age>18, desc) | 取数据集ds1中所有的age属性大于18的username字段信息，同时对username字段做倒排序 |
| ds1.select(username,age>18 and age<60, asc) | 取数据集ds1中所有的age属性大于18且小于60的username字段信息，同时对username字段做正排序 |

#### 2.group(分组罗列数据) ####

| 示例      | 说明            |
| :------ | :------------ |
| ds1.group(degree) | 对数据集ds1中degree字段进行分组 |
| ds1.group(degree,age>18) | 对数据集ds1中age属性大于18的所有的degree字段进行分组 |
| ds1.group(degree,age>18, asc) | 对数据集ds1中age属性大于18的所有的degree字段进行分组，同时对分组后的degree字段进行正排序 |

#### 3.sum(累加数据) ####

> sum是对数据集目标字段进行累加，所以目标字段一定要是一个数字类型，否则就会产生错误

| 示例      | 说明            |
| :------ | :------------ |
| ds1.sum(salary) | 对于数据集ds1中的salary字段进行累加 |
| ds1.sum(salary, age>30) | 对数据集ds1中age属性大于30的所有对象的salary字段进行累加 |

#### 4.count(统计数量) ####

> count是对数据集对象数量进行统计,统计数量不需要指定propertyName及order

| 示例      | 说明            |
| :------ | :------------ |
| ds1.count() | 对ds1数据集中对象数量进行统计 |
| ds1.count(age>30) | 统计数据集ds1中对象属性age值大30的所有对象的数量 |

#### 5.max(取最大值) ####

> max是对数据集对象中某一字段进行比较，取最大值，取最大值没有order。

| 示例      | 说明            |
| :------ | :------------ |
| ds1.max(salary) | 对于数据集ds1中的salary字段进行比较，取最大值 |
| ds1.max(salary, age>30) | 对数据集ds1中age属性大于30的所有对象的salary字段进行比较，取最大值 |

#### 6.min(取最小值) ####

> min是对数据集对象中某一字段进行比较，取最小值，取最小值没有order。用法同max()

#### 7.avg(取平均值) ####

> avg是对数据集对象中某一字段进行比较，取平均值，除不尽默认保留8位小数，取平均值没有order。用法同max()
